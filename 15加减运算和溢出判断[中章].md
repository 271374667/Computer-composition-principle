# 加减运算和移除判断

![加减运算和移除判断](https://pic.imgdb.cn/item/6252a1e8239250f7c5c050e1.png)

我们使用加法器直接使用原码进行运算对于硬件逻辑的要求太高了，所以我们**一般不使用原码进行运算**,==计算机中通常采用补码进行算术运算==

## 使用补码进行运算

使用补码进行运算，符号位一样参与运算

> 设机器字长为8位(含1位符号位)，A=15, B=-24,求[A+B]~补~和[A-B]~补~

$$
\begin{align*}
& A=+1111 \rightarrow \overbrace{0,0001111}^\text{原码}\rightarrow \overbrace{0,0001111}^\text{补码}\\
& B=-11000 \rightarrow 1,0011000 \rightarrow 11101000\\
\end{align*}
$$

计算公式

$$
\begin{align*}
&[A+B]_补\\
&= [A]_补+[B]_补 \\
&=0,0001111+1,1101000\\
&=1,1110111\\
\end{align*}
$$

把最终结果转换成原码,然后转换成真值

$$
10001001^\text{原码} = -9^\text{真值}
$$

### 对于补码快速转原码的一个方式

由之前所学的知识可知，负数补码移位的时候
- 最左边到最右边的1和反码一样
- 最右边的1到最后边和原码一样

所以我们可以有一个更快的方法来把负数补码转换成原码

1. 我们来数最右边的1，然后最右边的1到最右边原封不动
2. 然后最右边的1到最左边全部取反

比如
$$1,111011\underline{1} = 1,00010\underline{1}$$

$$
1,110\underline{1}000[补码] = 0,001\underline{1}000[原码]
$$

## 溢出

![溢出](https://pic.imgdb.cn/item/6252d8d0239250f7c537adb6.png)

可以看到，我们的A+C本来应该等于139,但是现在却等于-117,这就是数值发生了溢出

### 溢出判断

只有“正数+正数”才会上溢--正+正=负
只有“负数+负数”才会下溢--负+负=正

因为正数-负数的绝对值一定小于这两个数

计算机的溢出分为两种,
- 一种为==上溢==
- 一种为==下溢==

![上溢and下溢](https://pic.imgdb.cn/item/6252d9d1239250f7c539ff9f.png)

最常用的判断溢出方法(双符号位)

![双符号位](https://pic.imgdb.cn/item/6252dbf3239250f7c53ec9ff.png)

如果两个符号位相同表示没有溢出，如果不同则表示溢出

## 符号扩展(int->long)

防止溢出的方法就是把短数据变成长数据

![符号扩展](https://pic.imgdb.cn/item/6252dca2239250f7c5406634.png)

## 总结

![总结](https://pic.imgdb.cn/item/6252dcde239250f7c540e2b4.png)