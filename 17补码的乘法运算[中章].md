# 补码的乘法运算

补码的运算和原码的乘法运算非常相似，但是又有不同

补码一位乘法:
进行n轮加法、移位，最后再多来一次加法

每次加法可能+0、+[x]补、+[-x]补

![image-20220414144425038](https://pic.imgdb.cn/item/6257c2ee239250f7c5b419d1.png)

- 对于原码的移码(我们进行的是==逻辑右移==)高位补0
- 对于补码的移码(我们进行的是==算术右移==),此时我们补的个数需要根据**MQ中的最低位和辅助位**来确定

- 原码的符号位不参与运算(最后使用异或运算来判断)
- 补码的符号位参与运算

## 在机器内的流程

![image-20220414144852783](https://pic.imgdb.cn/item/6257c3f9239250f7c5b5d164.png)

### 辅助位

![image-20220414144911605](https://pic.imgdb.cn/item/6257c40c239250f7c5b5ef7b.png)

我们的辅助位是在**MQ的最右边加上了一个额外的位**(*理论上这个才是MQ的最低位*),因为我们的MQ加了一位，所以我们**其他的单元也相应的加了一个位**

![image-20220414145206543](https://pic.imgdb.cn/item/6257c4bb239250f7c5b70caf.png)

## 补码的一位乘法(手算模拟)

![image-20220414145722668](https://pic.imgdb.cn/item/6257c5f8239250f7c5b90f3a.png)

看起来好像很复杂，我们一点一点来说

1. 首先我们判断应该加什么,我们看到我们的辅助位是0，MQ的最低位是1

   根据算式$0(辅助位)-1(MQ最低位)=-1$,所以我们应该在这里加($+[-x]_补$)

$$
00.0000(ACC) + 00.1101([-x]_补)=00.1101(新的ACC)
$$

> 关于[-x~补~]怎么求
>
> **对任意的`x`,若已知`[x]补`,则把`[x]补`连同符号位的每一位都取反再`加1`即可得到`[-x]补`**
>
> 当x为正数时，设[x]补 = 01010
>
> ∵ [x]补 = 01010
> ∴ [x]原 = 01010
> ∴ [-x]原 = 11010
> ∴ [-x]补 = 10110
>
> 当x为负数时，设[x]补 = 11011
>
> ∵ [x]补 = 11011
> ∴ [x]原 = 10101
> ∴ [-x]原 = 00101
> ∴ [-x]补 = 00101
>
> 来源:<https://blog.csdn.net/qq_44685584/article/details/120205351>

我们加法操作结束之后就会进行一次**算术右移**(*符号位不动，新增的位我们用和符号位相同的数来填补*)
比如符号位是1，我们右移就补1，符号位是0,我们右移就补0

![image-20220414151059477](https://pic.imgdb.cn/item/6257c928239250f7c5be597d.png)

2. 此时我们的辅助位是1，MQ的最低位也是1,$1(辅助位)-1(MQ最低位)=0$,所以我们的补码就+0,然后再进行一次算术右移

![image-20220414151344071](https://pic.imgdb.cn/item/6257c9cc239250f7c5bf686e.png)

3. 根据上面的步骤一路算到最后

   ![image-20220414151522433](https://pic.imgdb.cn/item/6257ca2f239250f7c5bff847.png)

在最后我们还需要再进行最后一次加法(**这一次只有加法没有移位**)

![image-20220414151651381](https://pic.imgdb.cn/item/6257ca88239250f7c5c0887e.png)